Mini-pascal context-free grammar
(tested using https://web.stanford.edu/class/archive/cs/cs103/cs103.1156/tools/cfg/)

#basics
DIGIT -> 0|1|2|3|4|5|6|7|8|9
NUMBER -> DIGIT | DIGIT NUMBER
ADDITION -> +|-
MULTI -> *|/|div
COMP_SIGN -> <>|<|>|<=|>=|= 
VARIABLE -> ... (any set of characters, that is not a keyword)
TYPE -> integer|real

#variables
NUM_VAR -> NUMBER | VARIABLE
ARGUMENT -> NUM_VAR | VARIABLE[NUM_VAR] | FUNC_EXEC
ARGUMENT_LIST -> ARGUMENT | ARGUMENT, ARGUMENT_LIST
ARRAY_DEF -> array [ARGUMENT..ARGUMENT] of TYPE
LIST_OF_VARS -> VARIABLE | VARIABLE, LIST_OF_VARS
VAR_TYPE -> LIST_OF_VARS: TYPE; | LIST_OF_VARS: ARRAY_DEF;
LIST_OF_VAR_TYPES -> VAR_TYPE | VAR_TYPE LIST_OF_VAR_TYPES
VAR_DEF -> var LIST_OF_VAR_TYPES | ɛ

#math
EXPRESSION -> EXPRESSION ADDITION TERM | TERM
TERM -> TERM MULTI BR_NUM | BR_NUM
BR_NUM -> (EXPRESSION) | ARGUMENT

#logic
COMPARISON -> EXPRESSION COMP_SIGN EXPRESSION
CONDITION -> COMPARISON | EXPRESSION
SET_OF_CONDITIONS -> CONDITION  
					| CONDITION and SET_OF_CONDITIONS
					| CONDITION or SET_OF_CONDITIONS

#structure
PROGRAM_HEADER -> program VARIABLE;
BLOCK_DEF -> begin SET_OF_INSTR end; | INSTRUCTION;
SET_OF_INSTR -> INSTRUCTION | INSTRUCTION; SET_OF_INSTR
FUNC_HEADER -> function VARIABLE (LIST_OF_VAR_TYPES): TYPE;
PROC_HEADER -> procedure VARIABLE (LIST_OF_VAR_TYPES);
FP_HEADER -> PROC_HEADER | FUNC_HEADER
FP_STRUCT -> FP_HEADER VAR_DEF BLOCK_DEF
SET_OF_FPS -> ɛ | FP_STRUCT SET_OF_FPS

PROGRAM_STRUCT -> PROGRAM_HEADER VAR_DEF SET_OF_FPS begin SET_OF_INSTR end.

INSTRUCTION -> WHILE_DEF | IF_DEF | ASSIGNMENT | FUNC_EXEC
#instructions
WHILE_DEF -> while SET_OF_CONDITIONS do BLOCK_DEF
IF_DEF -> if(SET_OF_CONDITIONS) then BLOCK_DEF ELSE_DEF
ELSE_DEF -> else BLOCK_DEF | ɛ
ASSIGNMENT -> VARIABLE := EXPRESSION
FUNC_EXEC -> VARIABLE(ARGUMENT_LIST)
